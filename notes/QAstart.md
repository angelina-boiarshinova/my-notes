# Курс QA Start

## Урок 1

1. Жизненный цикл разработки ПО: стадии, роли, артефакты
2. Waterfall
3. V-Model
4. Spiral

## Урок 2
### Agile и фреймворки гибкой разработки

Agile манифест содержит 4 основных ценности и 12 принципов

Ценности манифеста:  

* Люди и из взаимодействие важнее процессов и инструментов
* Работающий продукт важнее исчерпывающей документации
* Готовность к изменениям важнее следования плану
* Общение с клиентом важнее чем согласование условий контракта

На базе манифеста появились фреймворки построения процессов, вот три самых популярных:  

* Extreme Programming (XP)  
  * autotests
  * unit tests
  * integration tests
  * pair programming
  * code review
  * continious integration (CI)
  * continious delivery (CD)

* Kanban (LEAN + Toyota Production System)  
  
  ![kanban](img\kanban.png)

* Scrum - это итерационный инкрементальный подход к гибкой разработке. 
  * внутри скрама работают спринтами (короткими итерациями 1-4 недели)
  * цель спринта - PSPI (potentionally shippable product increment)
  * каждый маленький спринт - это релиз

---

# Урок 3

## Виды и уровни тестирования

Тестирование - это НЕ процесс поиска багов! Поиск багов это лишь часть процесса тестирования

Acceptance criteria - критерий, который дает понять, что мы достигли приемлемого для нас уровня качества и можем выпускать продукт

Тестирование ПО - процесс, направленый на определение качества программного продукта, на соотвествие качества, которое ожидает заказчик, отвечает его требованиям.

Чем QA отличается от тестировщика?
Если тестируется готовый продукт после стадии девелепмента, и затем идет верификация, то это как правило тестировщик - Test Engineer, Quaality Control Engineer

QA (Quality assurance) - это инженер по обеспечению качества, те он должен начать свою работу на этапе Анализа и Архитектуры. И он должен уже начинать готовить какие-то тесты для архитектуры, участвовать в анализе. Чтобы на ранних стадиях находить и предотвращать возможные дефекты.

Вышесказанное - это скорее пока что теория, нежели практика.

SDET - software developer engeneer and test, сместь QA и разработчика, который берет на себя Unit тестирование, пишет автотесты, фиксит мелкие баги

## Виды тестирования

По стадии проведения процесса тестирования:
* альфа тестирование  
проводится на этапе разработки кода
* бета тестирование  
в тестирование отдается какой-то билд, обычно пробуют на какой-то фокус-группе
* бета плюс

По устройству системы:
* black box  
знаем что входит и что должно выходить, не лезем внутрь
* grey box
знаем какие-то внутренние процессы 
* white box
полностью ковыряемся в кишочках, работаем с исходным кодом

По направленности тестового сценария:

* positive  
проверяем, что система работает так, как мы ожидаем
* negative  
проверка вещей, которые не задуманы, не предусмотрен сценарий  
по статистике более 80% деффектов находится negative тестами

Этапы в общих чертах:

1. Понять что за продукт и как он должен вообще работать
2. Провести позитивные тесты - ключевой функционал
3. Негативные тесты

По выполнению кода:

* static  
работа с исходными кодами без запуска кода, или тестирование документации, например, находить несогласованность в use cases
* dynamic  
когда уже зашел на сайт / в приложение

По способу выполнения:

* manual
* automatic
* semi-auto

По объекту тестирования

* non functional  
    * UI - user interface, тестирование интерфейса взаимодействия системы с пользователем  
    * GUI - graphical user interface, тестирование внешнего вида приложения, размеры кнопок, шрифты, отступы  
    * usability - удобство работы
    * perfomance - тестируется производительность приложения, как быстро все грузится, сколько людей может быть в приложеннии и что-то делать одновременно  
        * stress testing - подается нагрузка, превышающая возможность программы/веб приложения
        * recoverability - способность к восстановлению после непредвиденно больших нагрузок, например
        * stability - как система будет себя вести при средних нагрузках и оставляют на несколько дней систему работать и потом читают логи. Обычно все это делается с помошью автотестов
    * localization - работает перевод, на всех экранах, ничо не плывет
    * internationalization - валюты, метрические системы, градусы
* functional  
тестирование бизнес-логики приложения. что приложение делает все так, как от него ожидалось
* security  
сохранность персональных данных, безопасность приложения
* regression testing - перепроверка того, что поломалось раньше и убедиться в том, что при переделке не сломалось что-то новое. такого тестирования очень много и это первый кандидат на автоматизацию.
* smoke testing - максимально быстрое тестирование основного функционала. Покрываются основные пути пользователя (все позитивные, парочка негативных). Обычно новый билд тестируется smoke тестом, если его не проходит, то смысла идти дальше нет
* sanity testing - покрытие тестами отдельных функционалов, например, переделали полностью регистрацию юзера, в этом случае уже не надо перепроверять фильтрацию в каталоге
* exploratory testing - тестирование без заранее описанных сценариев
* confirmation test - типо verification test in waterfall

## Уровни тестирования

1. Module (unit) level - тестирование функционала только какого-то модуля отдельно. Обычно выполняется на уровне кода, вызывая соответствующие методы. В основном эти тесты проводят разработчики
2. Integration level - тестирование взаимодействий между модулями. Как модули друг с другом взаимодействуют
3. System level - тестирование всей системы целиком, учитывая операционную систему, устройство, браузер